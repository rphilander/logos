(define list-set (fn (xs i val) (loop ((j 0) (remaining xs) (acc (list))) (if (empty? remaining) (reverse acc) (recur (add j 1) (rest remaining) (cons (if (eq j i) val (head remaining)) acc))))))

(define ref-display (fn (ref rev-map) (let (id (to-string ref)) (let (name (get rev-map id)) (if (nil? name) id name)))))

(define make-rev-syms (fn () (let (syms (symbols)) (fold (fn (acc name) (put acc (to-string (get syms name)) name)) (dict) (keys syms)))))

(define run-to-end (fn (s) (loop ((s s)) (if (eq (get s :status) :done) s (if (eq (get s :status) :error) s (recur (step-continue s)))))))

(define step-n (fn (s n) (loop ((s s) (n n)) (if (le n 0) s (if (eq (get s :status) :done) s (if (eq (get s :status) :error) s (recur (step-continue s) (sub n 1))))))))

(define step-until (fn (s pred) (loop ((s s)) (if (pred s) s (if (eq (get s :status) :done) s (if (eq (get s :status) :error) s (recur (step-continue s))))))))

(define step-watch (fn (s proj) (loop ((s s) (acc (list))) (let (next (cons (proj s) acc)) (if (eq (get s :status) :done) (reverse next) (if (eq (get s :status) :error) (reverse next) (recur (step-continue s) next)))))))

(define get-local (fn (s name) (loop ((scopes (reverse (get s :locals)))) (if (empty? scopes) nil (if (has? (head scopes) name) (get (head scopes) name) (recur (rest scopes)))))))

(define inject-local (fn (s name val) (let (locals (get s :locals)) (let (idx (loop ((i (sub (len locals) 1))) (if (lt i 0) nil (if (has? (nth locals i) name) i (recur (sub i 1)))))) (if (nil? idx) (if (empty? locals) (put s :locals (list (dict name val))) (put s :locals (list-set locals (sub (len locals) 1) (put (nth locals (sub (len locals) 1)) name val)))) (put s :locals (list-set locals idx (put (nth locals idx) name val))))))))

(define upstream (fn (sym) (let (rev (make-rev-syms)) (keys (loop ((queue (collect-refs (node-expr sym))) (visited (dict))) (if (empty? queue) visited (let (ref (head queue)) (let (display (ref-display ref rev)) (if (has? visited display) (recur (rest queue) visited) (let (sub-refs (collect-refs (node-expr ref))) (recur (append (rest queue) sub-refs) (put visited display true))))))))))))

(define downstream (fn (sym) (keys (loop ((queue (ref-by sym)) (visited (dict))) (if (empty? queue) visited (let (s (head queue)) (let (name (to-string s)) (if (has? visited name) (recur (rest queue) visited) (let (deps (ref-by s)) (recur (append (rest queue) deps) (put visited name true)))))))))))

(define between (fn (a b) (let (rev (make-rev-syms) target (ref-display b rev)) (loop ((queue (map (fn (r) (list r (list))) (collect-refs (node-expr a)))) (visited (dict))) (if (empty? queue) nil (let (entry (head queue)) (let (ref (head entry) path (nth entry 1)) (let (display (ref-display ref rev)) (if (eq display target) (append path (list display)) (if (has? visited display) (recur (rest queue) visited) (let (sub-refs (collect-refs (node-expr ref)) new-path (append path (list display))) (recur (append (rest queue) (map (fn (r) (list r new-path)) sub-refs)) (put visited display true)))))))))))))

(define library-contents (fn (lib) (let (syms (symbols) prefix (concat "node:" lib "/")) (filter (fn (name) (starts-with? (to-string (get syms name)) prefix)) (keys syms)))))

(define replay (fn (t) (if (int? t) (step-eval (get (nth (traces) t) "entry")) (step-eval (get t "entry")))))

(define count-fn-frames (fn (stack) (fold (fn (acc frame) (if (eq (get frame :kind) :fn-body) (add acc 1) acc)) 0 stack)))

(define trace-expand (fn (t & args) (let (limit (if (empty? args) 10 (head args)) pred (if (le (len args) 1) nil (nth args 1)) state (if (int? t) (replay t) (if (has? t "entry") (replay t) t)) rev (make-rev-syms) display-name (fn (nid) (if (eq nid "") "<anon>" (let (found (get rev nid)) (if (nil? found) nid found))))) (loop ((s state) (prev-depth 0) (events (list)) (count 0)) (if (eq (get s :status) :done) (reverse events) (if (eq (get s :status) :error) (reverse (cons (dict :type :error :error (get s :error) :depth prev-depth) events)) (let (next (step-continue s) depth (count-fn-frames (get next :stack))) (cond (gt depth prev-depth) (let (entry (dict :type :call :name (display-name (get next :node-id)) :depth depth)) (if (or (nil? pred) (pred entry)) (if (and (neq limit :all) (ge (add count 1) limit)) (reverse (cons entry events)) (recur next depth (cons entry events) (add count 1))) (recur next depth events count))) (lt depth prev-depth) (let (entry (dict :type :return :result (get s :result) :depth (add depth 1))) (if (or (nil? pred) (pred entry)) (if (and (neq limit :all) (ge (add count 1) limit)) (reverse (cons entry events)) (recur next depth (cons entry events) (add count 1))) (recur next depth events count))) true (recur next depth events count)))))))))
